#--
# Copyright (c) 2015-2017 Marius L. JÃ¸hndal
#
# See LICENSE in the top-level source directory for licensing terms.
#++
module PROIEL
  # A div object in a treebank.
  class Div < TreebankObject
    extend Memoist

    # Returns the ID of the div.
    #
    # PROIEL XML 2.0 lacks IDs for divs while later versions require them. For
    # PROIEL XML 2.0 unique IDs are generated by PROIEL::Treebank.
    #
    # @return [Fixnum] ID of the div
    attr_reader :id

    # @return [Source] source that the div belongs to
    attr_reader :source

    # @return [nil, String] title of the div
    attr_reader :title

    # @return [nil, String] presentation material before form
    attr_reader :presentation_before

    # @return [nil, String] presentation material after form
    attr_reader :presentation_after

    # @return [nil, String] ID of the div that this div is aligned to
    attr_reader :alignment_id

    # Creates a new div object.
    def initialize(parent, id, title, presentation_before, presentation_after, alignment_id, &block)
      @source = parent

      raise ArgumentError, 'integer expected' unless id.is_a?(Integer)
      @id = id

      raise ArgumentError, 'string or nil expected' unless title.nil? or title.is_a?(String)
      @title = title.freeze

      raise ArgumentError, 'string or nil expected' unless presentation_before.nil? or presentation_before.is_a?(String)
      @presentation_before = presentation_before.freeze

      raise ArgumentError, 'string or nil expected' unless presentation_after.nil? or presentation_after.is_a?(String)
      @presentation_after = presentation_after.freeze

      raise ArgumentError, 'integer or nil expected' unless alignment_id.nil? or alignment_id.is_a?(Integer)
      @alignment_id = alignment_id

      @children = block.call(self) if block_given?
    end

    # @return [Treebank] parent treebank object
    def treebank
      @source.treebank
    end

    # @return [String] language of the div as an ISO 639-3 language tag
    def language
      source.language
    end

    memoize :language

    # @return [String] a complete citation for the div
    def citation
      [source.citation_part, citation_part].join(' ')
    end

    # Computes an appropriate citation component for the div.
    #
    # The computed citation component must be concatenated with the citation
    # component provided by the source to produce a complete citation.
    #
    # @see citation
    #
    # @return [String] the citation component
    def citation_part
      tc = tokens.select(&:has_citation?)
      x = tc.first ? tc.first.citation_part : nil
      y = tc.last ? tc.last.citation_part : nil

      Citations.citation_make_range(x, y)
    end

    # Returns the printable form of the div with all token forms and any
    # presentation data.
    #
    # @return [String] the printable form of the div
    def printable_form(options = {})
      [presentation_before,
       @children.map { |s| s.printable_form(options) },
       presentation_after].compact.join
    end

    # Finds all sentences in the div.
    #
    # @return [Enumerator] sentences in the div
    #
    # @example Iterating sentences
    #   sentences.each { |s| puts s.id }
    #
    # @example Create an array with only reviewed sentences
    #   sentences.select(&:reviewed?)
    #
    # @example Counting sentences
    #   sentences.count #=> 200
    #
    def sentences
      @children.to_enum
    end

    # Finds all tokens in the div.
    #
    # @return [Enumerator] tokens in the div
    #
    # @example Iterating tokens
    #   tokens.each { |t| puts t.id }
    #
    # @example Create an array with only empty tokens
    #   tokens.select(&:is_empty?)
    #
    # @example Counting tokens
    #   puts tokens.count #=> 200
    #
    def tokens
      Enumerator.new do |y|
        @children.each do |sentence|
          sentence.tokens.each do |token|
            y << token
          end
        end
      end
    end

    # Returns the aligned div if any.
    #
    # @return [Div, NilClass] aligned div
    def alignment(aligned_source)
      alignment_id ? aligned_source.treebank.find_div(alignment_id) : nil
    end

    # Returns inferred aligned divs if any.
    #
    # @return [Array<Div>] inferred aligned divs
    def inferred_alignment(aligned_source)
      sentences.map do |sentence|
        sentence.inferred_alignment(aligned_source)
      end.flatten.compact.map(&:div).uniq
    end
  end
end
